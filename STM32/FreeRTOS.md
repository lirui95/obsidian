调用系统初始化，任务创建，开启任务调度



一、硬件基础
	CORTEX-M优先级与中断
		用于中断屏蔽的特殊寄存器
			1、PRIMASK 和 FAULTMASK 寄存器
				{
					PRIMASK用于屏蔽中断，适用于对时序要求比较高的任务
					（
						UCOS 中的临界区代码代码保护就是通过开关中断实现的(UCOSIII 也可以使用禁止任务调度的方法来实现临界区代码保护，这里不讨论这种情况)，而开关中断就是直接操作 PRIMASK寄存器的，所以在 UCOS 中关闭中断的时候时关闭了除复位、 NMI 和 HardFault 以外的所有中断！
					）
				}
			2、BASEPRI寄存器
				优先级阈值设置寄存器
				{
					FreeRTOS 的开关中断就是操作 BASEPRI 寄存器来实现的！它可以关闭低于某个阈值的中断，高于这个阈值的中断就不会被关闭！
				}
					

二、中断配置，宏 （FreeRTOS_config）
		一、临界代码段
			临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段，比如有的外设的初始化需要严格的时序，初始化过程中不能被打断。 FreeRTOS 在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。 FreeRTOS 系统本身就有很多的临界段代码，这些代码都加了临界段代码保护，我们在写自己的用户程序的时候有些地方也需要添加临界段代码保护
		ps:
			uxCriticalNesting 是个全局变量，用来记录临界段嵌套次数
		|
		二、一些不太理解的地方
			![[Pasted image 20240131185951.png]]
		

三、RTOS任务基础：多任务操作系统
	（初步上手 RTOS 系统首先必须掌握的也是任务的创建、删除、挂起和恢复等操作）
	一、多任务系统
		1. **抢占式多任务系统：** 在抢占式多任务系统中，操作系统具有任务调度器，可以根据任务的优先级和调度策略，动态地在不同的任务之间进行切换。在这种系统中，任务可以被强制性地暂停，并且在预定的时间片内进行切换，以确保每个任务都有机会执行。
		2. **协作式多任务系统：** 在协作式多任务系统中，任务的切换由任务自身来决定。每个任务执行一段时间后，必须主动让出CPU控制权给其他任务，从而实现任务之间的切换。在这种系统中，任务之间需要通过显式的方式进行协作，以确保合适的时机进行任务切换。
		|
	二、任务状态
		运行
		就绪
		阻塞：
			{
			任务进入阻塞态会有一个超时时间，当超过这个超时时间任务就会退出阻塞态，即使所等待的事件还没有来临
			}
		挂起
			{
			像阻塞态一样，任务进入挂起态以后也不能被调度器调用进入运行态， 但是进入挂起态的任务没有超时时间。任务进入和退出挂起态通过调用函数 vTaskSuspend()和 xTaskResume()。
			}
		![[Pasted image 20240131143429.png]]
		|
		三、任务优先级
			0~(configMAX_PRIORITIES-1)
			ps:
			优先级数字越低表示任务的优先级越低， 0 的优先级最低， configMAX_PRIORITIES-1 的优先级最高。空闲任务的优先级最低，为 0。
		|
		四、任务实现
			使用函数 xTaskCreate()或 xTaskCreateStatic()来创建任务，这两个函数的第一个参数 pxTaskCode，就是这个任务的任务函数
			ps:
			(1)、任务函数本质也是函数，所以肯定有任务名什么的，不过这里我们要注意：任务函数的返回类型一定要为 void 类型，也就是无返回值，而且任务的参数也是 void 指针类型的！任务函数名可以根据实际情况定义。
			|
			(2)、 任务的具体执行过程是一个大循环， for(; ; )就代表一个循环，作用和 while(1)一样，笔者习惯用 while(1)。
			|	
			(3)、循环里面就是真正的任务代码了，此任务具体要干的活就在这里实现！
			|
			(4)、 FreeRTOS 的延时函数，此处不一定要用延时函数，其他只要能让 FreeRTOS 发生任务切换的 API 函数都可以，**比如请求信号量、队列等，甚至直接调用任务调度器。 只不过最常用的就是 FreeRTOS 的延时函数**
			|
			(5)、 任务函数一般不允许跳出循环，如果一定要跳出循环的话在跳出循环以后一定要调用函数 vTaskDelete(NULL)删除此任务！
			FreeRTOS 的任务函数和 UCOS 的任务函数模式基本相同的，不止 FreeRTOS，其他 RTOS的任务函数基本也是这种方式的。
			|
			五、任务控制块
				存储任务属性
			六、任务堆栈
				如果使用的函数 xTaskCreate()创建任务(动态方法)的话那么任务堆栈就会由函数 xTaskCreate()自动创建，后面分析 xTaskCreate()的时候会讲解。如果使用函数 xTaskCreateStatic()创建任务(静态方法)的话就需要程序员自行定义任务堆栈，然后堆栈首地址作为函数的参数 puxStackBuffer 传递给函数
				|	
				ps:堆栈大小为所定义四倍


四：FreeRTOS任务相关API函数
	![[Pasted image 20240131184618.png]]
	|
	一|
		![[Pasted image 20240131184749.png]]创建动态任务
	|
	二、创建静态任务
			![[Pasted image 20240131184829.png]]
	|
	三、使用MPU保护
		![[Pasted image 20240131184953.png]]
	|
	四、删除任务
		![[Pasted image 20240131185022.png]]
	|
	五、常见的创建类型为：
		使用taskcreate创建开始任务，在开始任务中创建任务1.2...创建完成后删除任务开
		|
		如果创建静态任务，需要自己指定内存；
	六、任务挂起与恢复（实现任务运行与否）
		
	

五、RTOS列表与列表项
	为什么可以主动创建列表项任务？

六、调度器与任务管理
	不使用SYSTICK而使用PENDSV来实现任务切换的原因
	












操作系统实现任务管理 
奇怪于代码段的定义实现了什么功能 
systick应该还是按照内核时钟进行的，
![[Pasted image 20240128185611 1.png]]

任务创建与流程启动 ：
1-开发板硬件初始化 
2-创建appcreate任务
3-启动rtos ，开启多任务调度

systick ；或者是 操作系统的时钟滴答是由什么初始化的 
systick根据系统时钟产生中断，在中断处理函数中调用port.c的接口函数（这里有疑问，接口函数接受的传入参数是什么，还是说函数只需要开始运行即可），，根据中断进行加，作为RTOS的tick
另：tick的优先级

任务创建管理 
FreeRTOS中断配置与临界段
临界段代码 不能被打断的代码，可以用于外设初始化，RTOS进入临界段需要关闭中断，处理完之后打开。

操作系统的中断配置 
	这部分存在一些问题
	：
		临界代码段的实现，中断的设置
	中断的打开与关闭 
	临界代码段

rtos任务管理 （创建、删除、挂起、恢复）
任务状态：运行、阻塞、就绪、挂起
阻塞态有超时时间，超过时间会退出阻塞，而挂起没有超时时间
![[Pasted image 20240131143429.png]]

任务优先级：
任务执行按照优先级分配，0为最低，